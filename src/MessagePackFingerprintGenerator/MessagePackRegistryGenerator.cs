using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace MessagePackFingerprintGenerator;

[Generator]
public class MessagePackFingerprintRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var configProvider = GeneratorPipelines.ConfigProvider(context);

        var messagePackTypes = GeneratorPipelines.GetMessagePackTypes(context);

        var assemblyNameProvider =
            context.CompilationProvider.Select((compilation, _) => compilation.AssemblyName ?? "UnknownAssembly");

        var combined = assemblyNameProvider
            .Combine(messagePackTypes)
            .Combine(configProvider);

        context.RegisterSourceOutput(
            combined,
            (spc, data) =>
            {
                var ((assemblyName, types), referencedWithGenerator) = data;
                GenerateFingerprintRegistry(spc, assemblyName, types, referencedWithGenerator);
            });
    }

    private static void GenerateFingerprintRegistry(
        SourceProductionContext context,
        string assemblyName,
        IEnumerable<INamedTypeSymbol> types, 
        HashSet<string> referencedWithGenerator)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine($"namespace {assemblyName}.GeneratedRegistry;");
        sb.AppendLine();
        sb.AppendLine("public static class MessagePackFingerprintRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull(\"missing\")]");
        sb.AppendLine("    public static string? ShortPrint(object obj, string? missing = null, int length = 8) =>");
        sb.AppendLine("        GetFingerprint(obj)?[..length] ?? missing;");
        sb.AppendLine();
        sb.AppendLine("    [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull(\"missing\")]");
        sb.AppendLine("    public static string? GetFingerprint(object obj, string? missing = null) => obj switch");
        sb.AppendLine("    {");
        
        var sortedTypes = SortByInheritanceOrder(types.ToList());

        foreach (var symbol in sortedTypes)
        {
            var fullTypeName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat); 

            var assemblyOfType = referencedWithGenerator.Contains(symbol.ContainingAssembly.Name)
                ? symbol.ContainingAssembly.Name
                : assemblyName;
            var constName = fullTypeName.Replace("global::", "").Replace(".", "_");

            var fingerprintClass = $"global::{assemblyOfType}.GeneratedFingerprints.MessagePackFingerprints";

            sb.AppendLine($"        {fullTypeName} => {fingerprintClass}.{constName},");
        }

        sb.AppendLine("        _ => missing");
        sb.AppendLine("    };");
        sb.AppendLine("}");

        context.AddSource("MessagePackFingerprintRegistry.generated.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
    
    private static IEnumerable<INamedTypeSymbol> SortByInheritanceOrder(List<INamedTypeSymbol> types)
    {
        var typeSet = new HashSet<INamedTypeSymbol>(types, SymbolEqualityComparer.Default);
        var visited = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var sorted = new List<INamedTypeSymbol>();

        //Visitor pattern
        void Visit(INamedTypeSymbol symbol)
        {
            if (!visited.Add(symbol)) return;

            // Visit all known derived types first
            foreach (var namedSymbol in typeSet)
            {
                var baseType = namedSymbol.BaseType;
                if (baseType is not null && SymbolEqualityComparer.Default.Equals(baseType, symbol))
                {
                    Visit(namedSymbol);
                }
            }

            sorted.Add(symbol);
        }

        // Start from all root types
        foreach (var symbol in types)
        {
            Visit(symbol);
        }

        // Heuristic: push abstract and/or Union types to end
        return sorted
            .OrderBy(s => s.IsAbstract)
            .ThenBy(s => HasUnionAttribute(s) ? 1 : 0)
            .ToList();
    }

    private static bool HasUnionAttribute(INamedTypeSymbol symbol)
    {
        return Enumerable.Any(symbol.GetAttributes(), attr => attr.AttributeClass?.ToDisplayString() == "MessagePack.UnionAttribute");
    }

}